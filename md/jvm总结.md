## 1. jvm内存模型

![image-20210307195643331](https://raw.githubusercontent.com/tutu999999/pic/main/img/image-20210307195643331.png)

## 2. java对象生存周期及分配策略



## 3. 垃圾回收

### 3.1 垃圾判断算法(判断对象已死)

#### 判断一个对象已死

- 引用计数法

  >给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题

  ```java
  public class ReferenceCountingGc {
      Object instance = null;
  	public static void main(String[] args) {
  		ReferenceCountingGc objA = new ReferenceCountingGc();
  		ReferenceCountingGc objB = new ReferenceCountingGc();
  		objA.instance = objB;
  		objB.instance = objA;
  		objA = null;
  		objB = null;
  	}
  }
  ```

  

- 可达性分析算法

  > 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的

#### 对象引用

- 强引用

  ```Object object  = new Object()```

- 软引用

- 弱引用

- 虚引用

### 垃圾收集算法

- 标记清除法

  > 算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：
  >
  > - 效率问题
  >
  > - 空间问题（标记清除后会产生大量不连续的碎片）

- 复制算法

  > 它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收

- 标记整理法

  > 根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

- 分代收集法

  > 当前虚拟机的垃圾手机都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  >
  > 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集

### 垃圾收集器

- ### Serial收集器

- ### ParNew收集器

- ### Parallel Scavenge收集器

- ### Serial Old收集器

- ### Parallel Old收集器

- ### CMS收集器

- ### G1收集器

  

## 4. jvm 性能调优



